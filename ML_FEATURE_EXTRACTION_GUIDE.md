# ML Feature Extraction Guide for IBEX Regression Data

Quick reference for extracting features from IBEX regression runs for machine learning applications.

## Quick Start

### 1. Access Regression Metadata

```python
import sys
from pathlib import Path
sys.path.insert(0, '/home/a2zaustin/ibex/dv/uvm/core_ibex/scripts')

from metadata import RegressionMetadata
from test_run_result import TestRunResult

# Load the regression run
regression_dir = Path('/home/a2zaustin/ibex/dv/uvm/core_ibex/out/metadata')
md = RegressionMetadata.construct_from_metadata_dir(regression_dir)

print(f"Git commit: {md.git_commit}")
print(f"Simulator: {md.simulator}")
print(f"Creation time: {md.creation_datetime}")
print(f"Tests run: {len(md.tests_pickle_files)}")
```

### 2. Iterate Over Test Results

```python
# Access all test results
all_tests = []
for pickle_file in md.tests_pickle_files:
    trr = TestRunResult.construct_from_pickle(pickle_file)
    all_tests.append({
        'name': trr.testname,
        'seed': trr.seed,
        'testdotseed': f"{trr.testname}.{trr.seed}",
        'passed': trr.passed,
        'failure_mode': str(trr.failure_mode) if trr.failure_mode else 'none',
        'test_type': str(trr.testtype),
        'timeout_s': trr.timeout_s,
        'rtl_log': str(trr.rtl_log),
        'trace_csv': str(trr.dir_test / 'instr.csv') if trr.dir_test else None,
    })

import pandas as pd
df_tests = pd.DataFrame(all_tests)
print(df_tests.head())
```

### 3. Extract Coverage Metrics

```python
from report_lib.util import (
    parse_xcelium_cov_report,
    create_cov_summary_dict,
    calc_cg_average,
    IBEX_COVERAGE_METRICS
)
import os

# Get overall coverage summary
cov_dict = create_cov_summary_dict(md)
print("Coverage metrics:", cov_dict)
# Output: {'block': 0.78, 'branch': 0.68, 'statement': 0.82, ...}

# Parse individual coverage reports
cov_report_file = md.dir_cov_report / 'cov_report.txt'
if cov_report_file.exists():
    with open(cov_report_file) as f:
        cov_data = parse_xcelium_cov_report(f.read())
    
    # cov_data['ibex_top'] contains per-module metrics
    for metric in IBEX_COVERAGE_METRICS:
        key = f'{metric}-covered'
        if key in cov_data['ibex_top']:
            covered = cov_data['ibex_top'][key]['covered']
            total = cov_data['ibex_top'][key]['total']
            pct = covered / total if total else 0
            print(f"{metric}: {covered}/{total} ({pct:.1%})")
```

### 4. Get Coverage Labels (Pre-computed ML Features)

```python
import json

# This file is generated by coverage_labeler.py
labels_file = Path('/path/to/regression') / 'coverage_labels.jsonl'

coverage_labels = []
if labels_file.exists():
    with open(labels_file) as f:
        for line in f:
            record = json.loads(line)
            coverage_labels.append({
                'test': record['testdotseed'],
                'index': record['index'],
                'label': record['label'],  # 1 if contributes to coverage, 0 otherwise
                'triggers': record['triggers'],  # Which metrics changed
                'cov_delta': record['covered_deltas'],  # Items gained per metric
                'cg_before': record['covergroup_before'],
                'cg_after': record['covergroup_after'],
            })

df_labels = pd.DataFrame(coverage_labels)
print(df_labels.head())
```

### 5. Extract Test Parameters from Test List

```python
import yaml

# Load test configuration
testlist_file = Path('/home/a2zaustin/ibex/dv/uvm/core_ibex/riscv_dv_extension/testlist.yaml')
with open(testlist_file) as f:
    testlist = yaml.safe_load(f)

test_params = {}
for test_spec in testlist:
    test_name = test_spec['test']
    test_params[test_name] = {
        'type': 'RISCV_DV',
        'iterations': test_spec.get('iterations', 1),
        'description': test_spec.get('description', ''),
        'gen_opts': test_spec.get('gen_opts', ''),
        'instr_cnt': extract_instr_count(test_spec.get('gen_opts', '')),
    }

def extract_instr_count(gen_opts_str):
    """Extract instruction count from gen_opts string"""
    import re
    match = re.search(r'\+instr_cnt=(\d+)', gen_opts_str)
    return int(match.group(1)) if match else None

print(test_params)
```

### 6. Read Instruction Traces

```python
# Each test produces a CSV trace
test_dir = md.dir_tests / 'riscv_arithmetic_basic_test.1'
trace_csv = test_dir / 'instr.csv'

if trace_csv.exists():
    import pandas as pd
    df_trace = pd.read_csv(trace_csv)
    print(df_trace.columns)
    # Columns: pc, instr, operand, rs1_value, rs2_value, rd, rd_value, etc.
    print(f"Total instructions: {len(df_trace)}")
```

### 7. Build Feature Matrix for ML

```python
def extract_ml_features(regression_dir, output_file=None):
    """Extract complete feature matrix for ML"""
    md = RegressionMetadata.construct_from_metadata_dir(regression_dir)
    
    features = []
    for pickle_file in md.tests_pickle_files:
        trr = TestRunResult.construct_from_pickle(pickle_file)
        
        # Basic test info
        row = {
            'testname': trr.testname,
            'seed': trr.seed,
            'test_type': 'RISCV_DV' if 'riscv' in trr.testname else 'DIRECTED',
            'passed': int(trr.passed),
            'timeout': int(trr.failure_mode.value == 1) if trr.failure_mode else 0,
        }
        
        # Get test params if available
        if trr.testname in test_params:
            row['iterations'] = test_params[trr.testname]['iterations']
            row['instr_cnt'] = test_params[trr.testname]['instr_cnt']
        
        # Coverage (if available from per-test coverage)
        # Note: Individual test coverage is stored in trr.dir_fcov
        
        features.append(row)
    
    df = pd.DataFrame(features)
    
    if output_file:
        df.to_csv(output_file, index=False)
        print(f"Saved {len(df)} features to {output_file}")
    
    return df

df_features = extract_ml_features(
    Path('/home/a2zaustin/ibex/dv/uvm/core_ibex/out/metadata'),
    output_file='regression_features.csv'
)
print(df_features.describe())
```

---

## Key Data Files and Locations

### Per-Regression
```
$OUT_DIR/
├── metadata/
│   ├── metadata.pickle      # RegressionMetadata object
│   ├── metadata.yaml        # Human-readable version
│   └── [test.seed].pickle   # Individual TestRunResult
├── run/
│   ├── tests/[test.seed]/
│   │   ├── rtl_sim.log      # Full simulation log
│   │   ├── ibex.trace       # Raw instruction trace
│   │   ├── instr.csv        # Standardized CSV trace
│   │   └── coverage/test.ucd # Coverage database
│   ├── regr.log             # Text report
│   ├── report.json          # Machine-readable report
│   └── report.html          # HTML visualization
└── coverage/
    ├── report/
    │   ├── cov_report.txt   # Code coverage summary
    │   ├── cov_report_cg.txt # Functional coverage
    │   └── grading          # Coverage ranking
    └── merged/
        └── cov_db_runfile   # List of merged tests
```

### Configuration
```
/home/a2zaustin/ibex/
├── ibex_configs.yaml                    # Processor config options
├── dv/uvm/core_ibex/
│   ├── riscv_dv_extension/testlist.yaml # Test definitions
│   ├── directed_tests/directed_testlist.yaml
│   └── scripts/
│       ├── metadata.py                  # Load metadata
│       ├── test_run_result.py           # Test result class
│       ├── report_lib/util.py           # Coverage parsing
│       └── riscv_dv_extension/
│           └── ibex_log_to_trace_csv.py # Trace processing
```

### ML Output
```
coverage_labels.jsonl       # Coverage contribution labels (JSONL format)
```

---

## Coverage Metrics Available

### Code Coverage (7 metrics tracked per test/module)
- **block**: Basic block coverage - `{covered: int, total: int, pct: float}`
- **branch**: Branch decision coverage
- **statement**: Line/statement coverage
- **expression**: Expression coverage
- **toggle**: Signal toggle coverage (0→1, 1→0 transitions)
- **fsm**: Finite State Machine coverage
- **assertion**: Assertion coverage

### Functional Coverage
- **covergroup**: Per-module UVM covergroup averages (0-100%)

---

## Common Analysis Patterns

### Pattern 1: Find Tests Contributing Most Coverage

```python
df_labels = pd.read_json(
    'coverage_labels.jsonl',
    lines=True
)

# Tests that contributed to coverage
contributors = df_labels[df_labels['label'] == 1]
print(f"Coverage-contributing tests: {len(contributors)}/{len(df_labels)}")

# By metric
by_metric = pd.DataFrame(df_labels['triggers'].apply(pd.Series).stack()).value_counts()
print("Coverage contributions by metric:")
print(by_metric)
```

### Pattern 2: Identify Timeout vs Error Failures

```python
failures = df_tests[df_tests['passed'] == False]
print(f"Total failures: {len(failures)}")

timeouts = failures[failures['failure_mode'] == 'TIMEOUT(1)']
errors = failures[failures['failure_mode'] == 'LOG_ERROR(3)']
print(f"  Timeouts: {len(timeouts)}")
print(f"  Errors: {len(errors)}")
```

### Pattern 3: Correlation Between Test Params and Coverage

```python
# Merge test features with coverage labels
df_combined = df_features.merge(
    df_labels[['test', 'label', 'cov_delta']],
    left_on='testdotseed',
    right_on='test',
    how='left'
)

# Analyze correlation
print(df_combined.corr(['label', 'passed', 'instr_cnt']))
```

### Pattern 4: Timeline Analysis

```python
# Get coverage trajectory over test execution order
df_timeline = pd.read_json('coverage_labels.jsonl', lines=True)

# Plot cumulative coverage over time
for metric in ['block', 'branch', 'statement']:
    cov_values = []
    for _, row in df_timeline.iterrows():
        cov_values.append(row['metrics_after'].get(metric, 0))
    
    import matplotlib.pyplot as plt
    plt.plot(cov_values, label=metric)
    plt.xlabel('Test Index')
    plt.ylabel(f'{metric} Coverage (%)')
plt.legend()
plt.show()
```

---

## Dependencies

The analysis scripts require:
- Python 3.7+
- pathlib3x
- pyyaml
- typeguard ~= 2.13
- portalocker

Install with:
```bash
pip install -r /home/a2zaustin/ibex/python-requirements.txt
```

---

## Tips for ML Feature Engineering

1. **Normalize categorical test names**: Use one-hot encoding for test names
2. **Seed-based features**: Seed value is pseudo-random; consider grouping by modulo
3. **Time-series features**: Coverage delta is inherently ordered - good for sequence models
4. **Class imbalance**: Most tests may not contribute to coverage (label=0) - consider SMOTE or class weights
5. **Multiple outputs**: Can predict both pass/fail AND coverage contribution simultaneously
6. **Trace analysis**: Instruction traces enable sequence models (LSTM, Transformer) for anomaly detection

